{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p><code>typingiterable</code> is a simple python package for the actual typing of each element of an iterable with type hint notation.</p>"},{"location":"#install","title":"Install","text":"<pre><code>pip install git+ssh://git@github.com/osoken/typingiterable.git\n</code></pre>"},{"location":"#features-and-examples","title":"Features and Examples","text":""},{"location":"#actual-typing-with-type-hint-notation","title":"Actual Typing with Type Hint Notation","text":"<p>The following example shows how the main component <code>typingiterable.TypingIterable</code> works:</p> <pre><code>from dataclasses import dataclass\nfrom typingiterable import TypingIterable\n\n@dataclass\nclass User:\n    id: int\n    name: str\n\nraw_data = [{\"id\": 0, \"name\": \"Alice\"}, {\"id\": 1, \"name\": \"Bob\"}]\nfor d in TypingIterable[User](raw_data):\n    assert isinstance(d, User)\n</code></pre> <p>It is equivalent to write:</p> <pre><code>from dataclasses import dataclass\nfrom typingiterable import TypingIterable\n\n@dataclass\nclass User:\n    id: int\n    name: str\n\nraw_data = [{\"id\": 0, \"name\": \"Alice\"}, {\"id\": 1, \"name\": \"Bob\"}]\nfor d in (User(**d) for d in raw_data):\n    assert isinstance(d, User)\n</code></pre>"},{"location":"#error-handling","title":"Error Handling","text":"<p><code>typingiterable.TypingIterable</code> also has the error handling feature.</p> <pre><code>from dataclasses import dataclass\nfrom typingiterable import TypingIterable\nfrom collections.abc import Mapping\nfrom typing import Union\n\n@dataclass\nclass User:\n    id: int\n    name: str\n\ndef error_handler(d: Mapping[int, Union[int, str]], i: int, e: Exception) -&gt; None:\n    print(f\"{i}th element `{d}` is invalid due to the following error: {e}\")\n\nraw_data = [{\"id\": 0, \"name\": \"Alice\"}, {\"name\": \"lack of id\"}, {\"id\": 1, \"name\": \"Bob\"}]\nfor d in TypingIterable[User](raw_data, on_error=error_handler):\n    assert isinstance(d, User)\n</code></pre> <p>The above example prints the following string:</p> <pre><code>1th element `{'name': 'lack of id'}` is invalid due to the following error: User.__init__() missing 1 required positional argument: 'id'\n</code></pre> <p>and it doesn't stop iterating. The example is equivalent to write:</p> <pre><code>from dataclasses import dataclass\nfrom typingiterable import TypingIterable\nfrom collections.abc import Mapping\nfrom typing import Union\n\n@dataclass\nclass User:\n    id: int\n    name: str\n\nraw_data = [{\"id\": 0, \"name\": \"Alice\"}, {\"name\": \"lack of id\"}, {\"id\": 1, \"name\": \"Bob\"}]\nfor i, raw_d in enumerate(raw_data):\n    try:\n        d = User(**raw_d)\n    except Exception as e:\n        print(f\"{i}th element `{raw_d}` is invalid due to the following error: {e}\")\n    assert isinstance(d, User)\n</code></pre>"},{"location":"#automatic-unpacking-arguments","title":"Automatic Unpacking Arguments","text":"<p><code>typingiterable.TypingIterable</code> checks the signature and automatically unpacks the arguments. For functions which takes multiple positional arguments or multiple keyword arguments, such as <code>dataclass</code> and <code>pydantic.BaseModel</code>, it unpacks just like the above example. If the function is single-argument, no unpacking is done.</p> <pre><code>from typingiterable import TypingIterable\n\nraw_data = [\"1\", \"2\", \"3\", \"4\"]\nfor d in TypingIterable[int](raw_data):\n    assert isinstance(d, int)\n</code></pre>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#typingiterable","title":"<code>TypingIterable</code>","text":""},{"location":"usage/#typingiterablet","title":"<code>TypingIterable[T](...)</code>","text":"<p>Constractor.</p>"},{"location":"usage/#type-parameters","title":"Type Parameters:","text":"<ul> <li><code>T</code>: The type of each element to be returned.</li> </ul>"},{"location":"usage/#arguments","title":"Arguments:","text":"<ul> <li><code>it</code>: <code>Iterable[Any]</code>; The iterator of raw values.</li> <li><code>on_error</code>: <code>Callable[[Any, int, Exception], None]]</code>, optional, default=<code>None</code>; Function called when an error occurs on type casting. If the function doesn't raise any exceptions, the iteration continues. The <code>on_error</code> should accept three arguments, where <code>value</code>, <code>index</code> and <code>exception</code> mean the value which causes the exception, the index of the value and the exception respectively. If <code>None</code>, which is default, raises the exception and stops iteration.</li> </ul>"}]}